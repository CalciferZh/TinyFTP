# FTP实验报告

## 综述
### 服务器
我用纯C语言实现了一个轻量级的FTP服务器，能够与CentOS提供的默认ftp、Windows CMD的ftp进行正常通信。除了实验文档中要求的基础功能，还支持：

#### FTP标准命令(非基础要求)
1. REST（断点续传）
2. SIZE（文件大小）
3. PWD（工作路径）
4. NLST（简洁版LIST）

#### 非标准命令
1. ENCR（RSA加密，需要与client配合）
2. MULT（多线程传输，client无关）

### 客户端
我用python实现了轻量级的FTP客户端，满足了实验文档中的需求，能够与vsftpd进行正常通信，并能和上述服务器配合实现一些定制化功能。除了基础功能外，还支持：

1. crypt（RSA加密，与服务器配合）
5. ext（越过封装直接向服务器发送消息）
6. help（帮助信息）
7. ip（手动指定客户端ip，用于在客户端无法正确获得自身ip时）
9. mult（要求服务器开启多线程传输）
10. multirecv(多线程接收数据，服务器无关)
11. nlist（FTP: NLST）
15. pwd（FTP: PWD）
17. resume（续传）
20. size（FTP: SIZE）
21. thread（设置线程数）

### 工作量
server共3098行代码，有约800行来自GitHub的某RSA repo（后面详述），其余均为我自己完成。  

client共636行代码，全部自己完成。  

统计数据来源于文本编辑器暴力搜索'\n'数量，包含注释空行等等等等，不过大括号不换行=）  

## 详述
下面只介绍标准功能之外的功能。

### RSA加密传输
我没有使用标准的加密库，而是在GitHub上找了一个[简易的RSA实现](https://github.com/pantaloons/RSA)，实现了只能在我的服务器和客户端之间进行的RSA加密。这是一次非常惨痛的教训，由于没有使用标准库，我耗费了长达一周的时间对这个简易库进行修改、封装与debug。  

#### 功能介绍
客户端向服务器请求加密后，服务器会现场生成一对RSA密钥，将公钥明文发送给客户端，并发送一条加密消息给客户端进行确认。在此之后，二者直接的全部数据交流都是加密的（包括普通的命令与文件传输）。客户端随时可以向服务器要求关闭加密。  

#### 遇到的困难
##### RSA实现
我本以为找到一个库就能直接用，结果事实远非我所想。这个RSA实现本来只用于教学演示，可用性极差。为了能让服务器调用，我对它进行了一系列修改与封装，重写了三分之一的代码，修改了除最底层功能外的所有函数，才能正常调用。  

除了服务器，python实现的客户端也需要调用这个库进行加密解密。python调用c并不是很容易，因为如果直接调用C函数，其返回的指针指向的内存会被python当作垃圾回收掉。为了能让python正确地调用这个RSA库，我尝试了诸多方法，最后新加了一层封装才解决。  

##### 网络环境下加密数据的传输
RSA加密解密都是以“块”作为单位的，但网络传输更像是“流”。虽然底层上还是一个一个的数据包，但是并不能保证这些包内的数据都是“整块”的RSA加密后的数据。为了保证加密和解密的正常进行，就需要手动进行对齐。  

在读取文件时，每次读取的字节数应该是单块RSA能加密的字节数的整数倍，以避免padding 0的出现。唯一例外的是最后一个块，这时需要客户端根据事先得知的文件大小来移除padding 0。  

在接收数据时也需要将接收到的数据先对齐再进行解密；受限于缓冲区的大小，这种对齐与解密的操作又必须是与接收数据同步进行的，而不能简单地一次接收完毕全部数据再统一进行解密。  

上面的对齐操作理论上非常简单，但是实现起来很繁琐，尤其是在c这种古老的语言中。一方面，read和write并不能保证实际读写的字节数就是参数指定的字节数，另一方面还需要直接操作内存处理缓冲区的对齐问题。  

##### 抽象的内存操作
限于篇幅，这部分略过。


### 服务器的多进程与多线程
#### 多进程
服务器端的多进程是为了同时服务多个客户端。服务器每次收到新的请求时都会fork出一个新的进程来处理请求，并在请求结束后收回。没有使用多线程的原因是，如果不进行特殊处理的话，多个线程是共享同一个工作目录的，不同的线程之间就会相互干扰（比如CWD）。   

#### 多线程
为了提升性能，服务器在发送文件时采用了双线程进行操作：在同一时刻，一条线程负责从硬盘读取数据到缓存区，另一条线程负责将缓存区的数据发送出去。这样做是出于I/O速度瓶颈的考虑。但实际上，由于网络传输才是最严重的瓶颈，加之线程本身的额外开销，提升并不是非常明显。我进行了三次简单的测试：  
1. 缓存区均设置为8kb：双线程的传输速度要比单线程慢一个数量级  
2. 缓存区均设置为1mb：双线程速度约754mb/s，单线程速度约719mb/s  
3. 单线程缓存区设置为8kb，双线程缓存区设置为1mb：单线程速度为540mb/s，双线程速度为752mb/s，提升约40%  

上述测试都是在localhost上进行的，这是为了降低网络的影响，以体现出双线程的效果。在实际环境中双线程的优势会被大幅削弱。双线程只有在磁盘速度和网络速度相当、且处理器能够支持双线程时才具有优势。这种情况几乎是不存在的=）因此，服务器的双线程发送功能并不默认开启，可以通过MULT命令启动。  

附图：图一是缓存区8kb vs. 1mb，图二是缓存区1mb vs 1mb。

![](https://i.imgur.com/a5onFtY.png)

![](https://i.imgur.com/dRuwuNC.png)

### 客户端的多线程
客户端的多线程只适用于接收文件，方法非常暴力：同时开启N个线程登录服务器，每个线程下载文件的一部分，最后再将各个线程的下载结果合并到一起。我同样进行了简单的测试：单线程下载速度240.20kb/s，双线程下载速度334.36kb/s，四线程下载速度190.42kb/s。四线程速度下降的原因是客户端所在环境CPU只有双核。   

![](https://i.imgur.com/02OHoQN.png)

### 断点续传
这个只针对客户端从服务器上下载文件的情况。客户端检查一下已下载文件的大小，先向服务器发送REST命令，再下载即可；服务器会处理REST命令，将文件指针进行对应的偏移后发送。

### 其他的小功能
#### size
获取文件大小。这个是RSA加密必需的，否则难以判断文件末尾的padding 0有多少个。

#### pwd
获取当前工作路径。这个也是客户端多线程下载所需要的（获取多线程同时登录后要下载的文件路径）。

#### ext
绕过客户端封装，直接向服务器发送消息。比如"ext REST 100"就会直接发送给服务器"REST 100"。为客户端提供了一点扩展性。

#### ip
客户端无法正确得知自己的ip时，可以通过"ip"命令手动指定自身ip。

#### help
客户端可以通过"help"查看支持的命令。

### 其他的小细节
* 服务器尽量调用linux shell命令，这样可以让使用者的体验和直接在控制台操作保持一致。
* 服务器能够从sock连接中得知自己的公网ip。
* 服务器使用C标准库进行命令行参数的解析。
* 客户端总是只关注返回码的首位，提高了一点鲁棒性。
* 客户端输入登录密码时并不会显示。
* 客户端用了try...catch块，服务器用了很多错误判断与perror输出，尽量提高鲁棒性。

## 感受
1. 有标准库用标准库。自己实现一个“简易版”一点也不简易。这是实现RSA给我的教训。
2. 同样的协议也有千奇百怪的实现方式。考虑到这些因素时，服务器与客户端的鲁棒性要求就非常高。
3. 网络环境很复杂。比如在实现加密时就不得不考虑手动对齐数据的问题，在试图通过多线程提高性能时要意识到网络本身的瓶颈。
4. 这次作业不仅仅让我熟悉了socket，还学习了RSA加密、python调用C动态链接库、Linux C多进程与多线程、python多线程，可以说是非常充实了...

## credits:
https://github.com/pantaloons/RSA
